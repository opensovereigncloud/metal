// /*
// Copyright (c) 2022 T-Systems International GmbH, SAP SE or an SAP affiliate company. All right reserved
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// */

package machine

import (
	"context"
	"errors"
	"net"
	"strings"

	ipamv1alpha1 "github.com/onmetal/ipam/api/v1alpha1"
	inventoriesv1alpha1 "github.com/onmetal/metal-api/apis/inventory/v1alpha1"
	machinev1alpaha2 "github.com/onmetal/metal-api/apis/machine/v1alpha2"
	switchv1beta1 "github.com/onmetal/metal-api/apis/switch/v1beta1"
	domain "github.com/onmetal/metal-api/server-exploitation/domain/serverWarehouse"
	"github.com/onmetal/metal-api/types/common"
	oobv1 "github.com/onmetal/oob-operator/api/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/types"
	ctrlclient "sigs.k8s.io/controller-runtime/pkg/client"
)

var (
	errSwitchNotFound = errors.New("switch not found")
)

type Commissioning struct {
	client        ctrlclient.Client
	machine       *machinev1alpaha2.Machine
	serverAccount *inventoriesv1alpha1.Inventory
}

func NewMachineInstanceCommissioning(client ctrlclient.Client,
	serverAccount *inventoriesv1alpha1.Inventory,
) (*Commissioning, error) {
	machineInstance := &machinev1alpaha2.Machine{}
	if err := client.
		Get(
			context.Background(),
			types.NamespacedName{
				Namespace: serverAccount.Namespace,
				Name:      serverAccount.Name,
			},
			machineInstance); err != nil {
		return nil, err
	}
	return &Commissioning{
		client:        client,
		machine:       machineInstance,
		serverAccount: serverAccount,
	}, nil
}

func (m *Commissioning) InstanceCommissioning() domain.Instance {
	m.machine.Spec = updateInstanceSpecData(m.machine.Spec, m.serverAccount.Spec.System)
	m.updateInstanceStatus()
	return NewMachineInstance(m.machine)
}

func (m *Commissioning) updateInstanceStatus() {
	if m.machine.Status.Inventory.Name == "" {
		m.machine.Status.Inventory = common.NewObjectMetadata(
			m.serverAccount.Name,
			m.serverAccount.Namespace).
			Reference()
	}
	if m.machine.Status.OOB.Name == "" {
		serverName, serverNamespace := m.findServerByUUID(m.serverAccount.Spec.System.ID)
		m.machine.Status.OOB = common.NewObjectMetadata(
			serverName,
			serverNamespace).
			Reference()
	}

	if m.machine.Status.Reservation.Status == "" {
		m.machine.Status.Reservation.Status = "Available"
	}
	m.machine.Status.Interfaces = m.updateMachineInterfaces()

	m.machine.Status.Network = m.updateNetworkStatus(m.machine.Status.Interfaces)

	m.machine.Status.Health = m.updateHealthStatus()
	if m.machine.Status.Health == machinev1alpaha2.MachineStateHealthy {
		m.machine.Status.Orphaned = false
	} else {
		m.machine.Status.Orphaned = true
	}
}

func (m *Commissioning) findServerByUUID(serverUUID string) (string, string) {
	obj := &oobv1.OOBList{}
	filter := &ctrlclient.ListOptions{
		LabelSelector: ctrlclient.MatchingLabelsSelector{
			Selector: labels.SelectorFromSet(map[string]string{machinev1alpaha2.UUIDLabel: serverUUID})}}

	if err := m.client.List(context.Background(), obj, filter); err != nil {
		return "", ""
	}
	if len(obj.Items) == 0 {
		return "", ""
	}
	return obj.Items[0].Name, obj.Items[0].Namespace
}

func (m *Commissioning) updateMachineInterfaces() []machinev1alpaha2.Interface {
	machineInterfaces := make([]machinev1alpaha2.Interface, 0, numberOfInterfacesToAchieveSingleAvailability)
	serverAccountInterfaces := m.serverAccount.Spec.NICs
	for nic := range serverAccountInterfaces {
		if len(serverAccountInterfaces[nic].LLDPs) == 0 {
			machineInterfaces = baseConnectionInfo(&serverAccountInterfaces[nic], machineInterfaces)
			continue
		}

		s, err := m.getSwitchByChassisID(serverAccountInterfaces[nic].LLDPs[0].ChassisID)
		if err != nil {
			machineInterfaces = baseConnectionInfo(&serverAccountInterfaces[nic], machineInterfaces)
			continue
		}

		switchInterface, ok := s.Status.Interfaces[serverAccountInterfaces[nic].LLDPs[0].PortDescription]
		if !ok || switchInterface == nil {
			machineInterfaces = baseConnectionInfo(&serverAccountInterfaces[nic], machineInterfaces)
			continue
		}
		machineInterfaces = interfaceInfoEnrichment(
			s.ObjectMeta, &serverAccountInterfaces[nic],
			machineInterfaces, s.Name, switchInterface)
	}
	return machineInterfaces
}

func (m *Commissioning) updateNetworkStatus(
	machineInterfaces []machinev1alpaha2.Interface) machinev1alpaha2.Network {
	machineInterfaceCount := len(machineInterfaces)
	return machinev1alpaha2.Network{
		Ports:        machineInterfaceCount,
		Redundancy:   NetworkRedundancy(machineInterfaceCount),
		UnknownPorts: countUnknownPorts(machineInterfaces),
	}
}

func (m *Commissioning) getSwitchByChassisID(chassisID string) (*switchv1beta1.Switch, error) {
	obj := &switchv1beta1.SwitchList{}
	filter := &ctrlclient.ListOptions{
		LabelSelector: labels.SelectorFromSet(
			map[string]string{switchv1beta1.LabelChassisID: strings.ReplaceAll(
				chassisID, ":", "-"),
			})}
	if err := m.client.List(context.Background(), obj, filter); err != nil {
		return nil, err
	}
	if len(obj.Items) == 0 {
		return nil, errSwitchNotFound
	}
	return &obj.Items[0], nil
}

func interfaceInfoEnrichment(
	sw metav1.ObjectMeta,
	nicsSpec *inventoriesv1alpha1.NICSpec,
	machineInterfaces []machinev1alpaha2.Interface,
	switchUUID string,
	switchInterface *switchv1beta1.InterfaceSpec) []machinev1alpaha2.Interface {
	return append(machineInterfaces, machinev1alpaha2.Interface{
		Name:  nicsSpec.Name,
		Lanes: switchInterface.Lanes,
		IPv4: &machinev1alpaha2.IPAddressSpec{
			Address: interfaceIPAddress(
				switchInterface,
				ipamv1alpha1.CIPv4SubnetType)},
		IPv6: &machinev1alpaha2.IPAddressSpec{
			Address: interfaceIPAddress(
				switchInterface,
				ipamv1alpha1.CIPv6SubnetType)},
		Moved:           isInterfaceMoved(nicsSpec, machineInterfaces),
		Unknown:         false,
		SwitchReference: common.ResourceReference{Namespace: sw.Namespace, Name: sw.Name},
		Peer: &machinev1alpaha2.Peer{
			LLDPSystemName:      switchUUID,
			LLDPChassisID:       nicsSpec.LLDPs[0].ChassisID,
			LLDPPortID:          nicsSpec.LLDPs[0].PortID,
			LLDPPortDescription: nicsSpec.LLDPs[0].PortDescription,
		},
	})
}

func interfaceIPAddress(
	switchNIC *switchv1beta1.InterfaceSpec,
	subnetAddressType ipamv1alpha1.SubnetAddressType) string {
	var ipAddress string
	for _, addr := range switchNIC.IP {
		ip, ipNet, err := net.ParseCIDR(addr.Address)
		if err != nil {
			return ipAddress
		}
		if size, _ := ipNet.Mask.Size(); size < serverNetworkSize() {
			return ipAddress
		}
		if ipByteRepr := ip.To4(); ipByteRepr != nil && subnetAddressType == ipamv1alpha1.CIPv4SubnetType {
			ipByteRepr[3]++
			machineAddr := net.IPNet{
				IP:   ip,
				Mask: ipNet.Mask,
			}
			return machineAddr.String()
		}
		if ipByteRepr := ip.To16(); ipByteRepr != nil && subnetAddressType == ipamv1alpha1.CIPv6SubnetType {
			ipByteRepr[15]++
			machineAddr := net.IPNet{
				IP:   ip,
				Mask: ipNet.Mask,
			}
			return machineAddr.String()
		}
	}
	return ipAddress
}

// nolint
func serverNetworkSize() int {
	return 30
}

func baseConnectionInfo(
	nicsSpec *inventoriesv1alpha1.NICSpec,
	machineInterfaces []machinev1alpaha2.Interface) []machinev1alpaha2.Interface {
	if len(nicsSpec.LLDPs) != 1 {
		return append(machineInterfaces, machinev1alpaha2.Interface{
			Name:    nicsSpec.Name,
			Unknown: true,
		})
	}
	return append(machineInterfaces, machinev1alpaha2.Interface{
		Name:    nicsSpec.Name,
		Unknown: false,
		Moved:   isInterfaceMoved(nicsSpec, machineInterfaces),
		Peer: &machinev1alpaha2.Peer{
			LLDPSystemName:      nicsSpec.LLDPs[0].SystemName,
			LLDPChassisID:       nicsSpec.LLDPs[0].ChassisID,
			LLDPPortID:          nicsSpec.LLDPs[0].PortID,
			LLDPPortDescription: nicsSpec.LLDPs[0].PortDescription,
		},
	})
}

func isInterfaceMoved(newInterfaceState *inventoriesv1alpha1.NICSpec,
	machineInterfaces []machinev1alpaha2.Interface) bool {
	for mi := range machineInterfaces {
		if machineInterfaces[mi].Name != newInterfaceState.Name {
			continue
		}
		if machineInterfaces[mi].Peer == nil || len(newInterfaceState.LLDPs) == 0 {
			continue
		}
		if machineInterfaces[mi].Peer.LLDPChassisID != newInterfaceState.LLDPs[0].ChassisID {
			return true
		}
	}
	return false
}

func countUnknownPorts(machineInterfaces []machinev1alpaha2.Interface) int {
	var count int
	for machinePort := range machineInterfaces {
		if !(machineInterfaces[machinePort].Unknown) {
			continue
		}
		count++
	}
	return count
}

func (m *Commissioning) updateHealthStatus() machinev1alpaha2.MachineState {
	if m.machine.Status.OOB.Name == "" || m.machine.Status.Inventory.Name == "" ||
		!highAvailabilityRedundancy(len(m.machine.Status.Interfaces)) {
		return machinev1alpaha2.MachineStateUnhealthy
	} else {
		return machinev1alpaha2.MachineStateHealthy
	}
}

func copySizeLabelsToMachine(machineLabels, serverAccountLabels map[string]string) map[string]string {
	for key, value := range serverAccountLabels {
		if !strings.Contains(key, inventoriesv1alpha1.CLabelPrefix) {
			continue
		}
		machineLabels[key] = value
	}
	return machineLabels
}
